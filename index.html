<html>
<head>
  <meta charset="utf-8">
  <script src="js/d3.v3.min.js"></script>
  <script src="js/topojson.v0.min.js"></script>
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="https://code.jquery.com/ui/1.10.4/jquery-ui.min.js"></script>
  <style>
      h3 {
        margin-left: 200px;
        color: black;
      }
      #info {
         margin-left: 200px;
         width: 1400px;
      }
      #chartContainer {
         margin-top: 50px;
         margin-left: 200px;
         width: 900px;
      }
      #minslider-lable, #maxslider-lable {
         margin-left: 200px;
      }
      #minslider #maxslider {
         width: 200px;
      }
      path {
        stroke: white;
        stroke-width: 0.25px;
        fill: grey;
      }
      .tooltip {
          position: absolute;
          top: 10px;
          left: 10px;
      }
      .slider {
        -webkit-appearance: none;
        width: 300px;
      }
      .slider::-moz-range-thumb {
          padding: 1.5px;
      }
      .slider:active::-moz-range-thumb {
          background: red;               
      }
      .slider::-webkit-slider-thumb {
	      -webkit-appearance: none;
      	padding: 1.5px;
      }
      .slider:active::-webkit-slider-thumb {
	      -webkit-appearance: none;
      	background: red;
      }
  </style>
</head>
<body>
  <!--http://www.tnoda.com/blog/2013-12-07-->
  <h3>Digital Nomad Cities in the world</h3>
  <div id="info">Digital nomads are people that use technology in order to work remotely and live an independent and nomadic lifestyle. <a href="https://nomadlist.com">Nomadlist</a> finds the best cities in the world for digital nomads. Based on their data, I have plotted the cities on a map. Clicking on a city links you to the details on nomadlist. The tooltip shows the name of the city and some properties like safety, WiFi connection, weather,etc. The sliders can be used to filter on overall score.
  </div>
  <p></p>
  <label id="minslider-lable" for="minslider">Min score = <span id="minslider-value">…</span></label> <input type="range" min="1" max="10" step="0.1" id="minslider" class="slider"> <br/>
  <label id="maxslider-lable" for="maxslider">Max score = <span id="maxslider-value">…</span></label> <input type="range" min="1" max="10" step="0.1" id="maxslider" class="slider">
  <div id="chartContainer">
    <button id="zoom_in">+</button>
    <button id="zoom_out">-</button>
  </div>
  <script type="text/javascript">

  var width = 1400,
      height = 650;
  
  var projection = d3.geo.mercator()
      .center([0,35])
      .scale(200)
      .rotate([0,0]);
  
  var zoom = d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoomed);
  
  var svg = d3.select("#chartContainer")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .call(zoom);
  
  var path = d3.geo.path()
      .projection(projection);
  
  var g = svg.append("g");
  
  var tooltip = d3.select("body").append("div").
                attr("class", "tooltip")
                .style("position", "absolute")
                .style("z-index", "10")
                .style("visibility", "hidden")
                .style("color", "white")
                .style("padding", "8px")
                .style("background-color", "rgba(0, 0, 0, 0.75)")
                .style("border-radius", "6px")
                .style("font", "12px sans-serif")
                .text("tooltip");
                
  //human readable score from 0 to 10              
  var calcScore = function(score){
    return Math.round(parseFloat(score) * 100) / 10
  }
  var calcRadius = function(d,i){
	  return Math.round(parseFloat(d.score) * 100) / 20
	}
	
  //colorScale = d3.scale.ordinal().range(["#7479BC","#7C2833","#E7AC37","BDE7AE","E17250","ECF809","FC6E61"]);
  //colorScale = d3.scale.linear().domain([0,1]).range(["#ff6666","#ff0000"]);
  //var colorScale = d3.scale.linear().domain([0,1]).range(["green","red"]);
  //var color = d3.scale.linear()
    //.domain([0, 1])
    //.range(["white", "red"]);
  
  //this function will be run everytime we mouse over an element
	var mouseOver = function(d, i) {
		tooltip.html(d.city + " (" + d.country + ") :" + calcScore(d.score) + '<br/>' + 
		            "temperature (C):" + d.tempcls + '<br/>' +
		            "wifi connection score:" + calcScore(d.scorewifi) + '<br/>' +
		            "download speed (Mbps):" + d.dlspeed + '<br/>' +
		            "places to work score:" + calcScore(d.scoreplaces2work) + '<br/>' +
		            "safety score:" + calcScore(d.scoresafety) + '<br/>' +
		            "people checked in:" + d.checkins
		            );
    tooltip.style("visibility", "visible");
		d3.select(this).attr({
      r: 10
    });
	}
	var mouseMove = function(d,i){
	  return tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");
	}
	var mouseOut = function(d,i){
	  tooltip.style("visibility", "hidden");
	  d3.select(this).attr({
      r: calcRadius(d)
    });
	}
	var calcCol = function(d,i){
	  return color(d.score)
	}
	
  // load and display the World
  d3.json("data/world-110m2.json", function(error, topology) {
  
  // load and display the cities
  d3.csv("data/nomadcities.csv", function(error, data) {
      g.selectAll("circle")
         .data(data)
         .enter()
         .append("a")
  				  .attr("xlink:href", function(d) {
  					  return "https://nomadlist.com" + d.url;}
  				  ).attr("target", "_blank")
         .append("circle")
         .attr("cx", function(d) {
                 return projection([d.lon, d.lat])[0];
         })
         .attr("cy", function(d) {
                 return projection([d.lon, d.lat])[1];
         })
         .attr("r", calcRadius)
         .attr('fill-opacity', 0.5)
         .style("fill", "red")
         .style("stroke", function(d) {
                 if(Math.round(parseFloat(d.score) * 100) / 10 == 10) { return "black"}
         })
         .style("stroke-width", function(d) {
                 if(Math.round(parseFloat(d.score) * 100) / 10 == 10) { return 3}
         })
         .on("mouseover", mouseOver)
         .on("mousemove", mouseMove)
         .on("mouseout", mouseOut);
         svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) < 9; }).style("visibility", "hidden");
         svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) >= 9; }).style("visibility", "visible");
  });
  
  g.selectAll("path")
        .data(topojson.object(topology, topology.objects.countries)
            .geometries)
      .enter()
        .append("path")
        .attr("d", path)
  });
  
  // when the input range changes update the circle 
  d3.select("#minslider").on("input", function() {
    updateMin(+this.value);
  });
  d3.select("#maxslider").on("input", function() {
    updateMax(+this.value);
  });
  
  // update the elements
  function updateMin(sliderVal) {
    // adjust the text on the range slider
    d3.select("#minslider-value").text(sliderVal);
    d3.select("#minslider").property("value", sliderVal);
    var maxValue = d3.select("#maxslider-value").text()   
  
    // update visibility of circles
    svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) >= sliderVal && (Math.round(parseFloat(d.score) * 100) / 10) <= maxValue; }).style("visibility", "visible");
    svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) < sliderVal; }).style("visibility", "hidden");
  }
  // update the elements
  function updateMax(sliderVal) {
    // adjust the text on the range slider
    d3.select("#maxslider-value").text(sliderVal);
    d3.select("#maxslider").property("value", sliderVal);
    var minValue = d3.select("#minslider-value").text()   
  
    // update visibility of circles
    svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) < sliderVal && (Math.round(parseFloat(d.score) * 100) / 10) >= minValue; }).style("visibility", "visible");
    svg.selectAll("circle").filter(function(d) {return (Math.round(parseFloat(d.score) * 100) / 10) >= sliderVal; }).style("visibility", "hidden");
  }
  
  // Initial starting viz of the circle 
  updateMin(9);
  updateMax(10);
  
  function zoomed() {
    g.attr("transform",
        "translate(" + zoom.translate() + ")" +
        "scale(" + zoom.scale() + ")"
    );
  }

  function interpolateZoom (translate, scale) {
      var self = this;
      return d3.transition().duration(350).tween("zoom", function () {
          var iTranslate = d3.interpolate(zoom.translate(), translate),
              iScale = d3.interpolate(zoom.scale(), scale);
          return function (t) {
              zoom
                  .scale(iScale(t))
                  .translate(iTranslate(t));
              zoomed();
          };
      });
  }

  function zoomClick() {
      var clicked = d3.event.target,
          direction = 1,
          factor = 0.2,
          target_zoom = 1,
          center = [width / 2, height / 2],
          extent = zoom.scaleExtent(),
          translate = zoom.translate(),
          translate0 = [],
          l = [],
          view = {x: translate[0], y: translate[1], k: zoom.scale()};
  
      d3.event.preventDefault();
      direction = (this.id === 'zoom_in') ? 1 : -1;
      target_zoom = zoom.scale() * (1 + factor * direction);
  
      if (target_zoom < extent[0] || target_zoom > extent[1]) { return false; }
  
      translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
      view.k = target_zoom;
      l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];
  
      view.x += center[0] - l[0];
      view.y += center[1] - l[1];
  
      interpolateZoom([view.x, view.y], view.k);
  }

  d3.selectAll('button').on('click', zoomClick);
  </script>
</body>
</html>